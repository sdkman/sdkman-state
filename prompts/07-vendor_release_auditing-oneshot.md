# Vendor Release Auditing

This feature implements comprehensive audit logging for vendor release operations (POST and DELETE) in the SDKMAN State API. Every creation and deletion of a version will be captured in a dedicated audit table with sufficient information to track who performed the action, when it occurred, and what version data was affected.

## Rules

**Before implementing, you MUST read and internalize:**
- rules/kotlin.md
- rules/domain-driven-design.md
- rules/kotest.md

**If this prompt conflicts with the rules, THE RULES WIN.** Update this prompt to align with the rules.

## Requirements

- Create a new `vendor_audit` table to store audit records
- Capture audit records for POST and DELETE operations on `/versions` endpoint only
- Each audit record must capture:
  - User/actor from authentication credentials (username)
  - Timestamp of when the operation occurred
  - Operation type (POST or DELETE)
  - Complete version data as JSON (the version that was created or deleted)
- Audit logging failures must not cause the actual operation to fail
- Audit logging failures should be logged as warnings for monitoring
- No API endpoint for querying audit logs (database access only)
- Audit records are stored indefinitely with no automatic cleanup
- Use Flyway migration to create the vendor_audit table

## Domain

```kotlin
// Audit record representation
@Serializable
data class AuditRecord(
    val id: Long = 0,  // Auto-generated by database
    val username: String,
    val timestamp: Instant,
    val operation: AuditOperation,
    val versionData: String  // JSON representation of Version
)

@Serializable
enum class AuditOperation {
    POST,
    DELETE
}

// Repository interface for audit operations
interface AuditRepository {
    suspend fun recordAudit(
        username: String,
        operation: AuditOperation,
        version: Version
    ): Either<DatabaseFailure, Unit>
}
```

## Extra Considerations

### Error Handling Philosophy
- **Audit failures must never block business operations**
- If audit logging fails, log a warning with full error details but allow the POST/DELETE to succeed
- Consider Either's `tapLeft` to handle audit failures gracefully
- **Under no conditions use try-catch for error handling**. Keep it functional!
- Audit repository methods should return `Either<DatabaseFailure, Unit>` for proper error handling

### Data Storage Strategy
- Store version data as JSON text/jsonb column for flexibility and easy querying
- Use PostgreSQL's `jsonb` type for efficient JSON querying and indexing
- Serialize the complete `Version` object to JSON, preserving all fields including Option types
- This allows recreating the exact state of what was created or deleted

### Authentication Context
- Username comes from the basic authentication credentials already implemented
- POST and DELETE endpoints already require authentication
- Need to extract username from authentication context and pass to audit layer

### Performance Considerations
- Audit logging is synchronous but should be fast (single INSERT)
- If audit table grows very large, consider adding indexes on username and timestamp
- Database connection pooling should handle concurrent audit writes
- Future optimization: could move to async/fire-and-forget pattern if needed

### Current Architectural State
- **IMPORTANT**: This application is not yet compliant with hexagonal architecture
- The codebase will be refactored for hexagonal architecture in the future
- **Follow existing established patterns** rather than forcing architectural changes now
- Current pattern: Repository interfaces in domain layer, implementations in repos package, routing calls repositories directly
- Keep audit implementation consistent with how VersionsRepository is currently used

### Separation of Concerns
- Audit logic should not pollute routing layer with database details
- Keep repository abstraction: interface in domain, implementation in repos
- Routing layer calls both version repository and audit repository directly (current pattern)

## Testing Considerations

All tests should be written using Kotest's ShouldSpec style to match the existing test structure.

### Integration Tests - Happy Path
- POST /versions creates version AND creates corresponding audit record with operation=POST
- DELETE /versions deletes version AND creates corresponding audit record with operation=DELETE
- Audit record captures correct username from authentication
- Audit record captures current timestamp (within reasonable delta)
- Audit record contains complete version data as valid JSON

### Integration Tests - Audit Failure Handling
- Mock or simulate audit repository failure during POST operation
  - Verify version is still created successfully
  - Verify warning is logged (check logs or log capture)
- Mock or simulate audit repository failure during DELETE operation
  - Verify version is still deleted successfully
  - Verify warning is logged

### Data Integrity Tests
- Query vendor_audit table after POST and verify record structure
- Deserialize version_data JSON back to Version object
- Verify Option fields are correctly serialized/deserialized (distribution, checksums)
- Verify enum values (operation, platform, distribution) are correctly stored

### Edge Cases
- POST with all optional fields populated (distribution, all checksums)
- POST with minimal required fields only
- DELETE with distribution=None vs distribution=Some(value)
- Concurrent POST/DELETE operations create separate audit records

## Implementation Notes

### Order of Implementation
1. **Read and internalize rules files** - Understand architecture, Kotlin patterns, and testing approach
2. Create Flyway migration for `vendor_audit` table
3. Define `AuditRecord` and `AuditOperation` domain types
4. Create `AuditRepository` interface in domain layer
5. Implement `AuditRepository` using Jetbrains Exposed in infrastructure layer
6. Integrate audit logging into POST /versions endpoint routing
7. Integrate audit logging into DELETE /versions endpoint routing
8. Write comprehensive Kotest specifications

### Technology Preferences
- Use Jetbrains Exposed ORM for audit repository implementation (consistent with existing `VersionsRepository`)
- Use kotlinx.serialization to serialize Version to JSON string
- Use PostgreSQL jsonb column type for version_data field
- Use Instant type from kotlinx-datetime for timestamp
- Follow Arrow `Either` patterns for error handling (consistent with codebase)
- Use suspend functions for async database operations (consistent with existing repository pattern)

### Database Migration

Create a new Flyway migration file: `V7__create_vendor_audit_table.sql`

```sql
CREATE TABLE IF NOT EXISTS vendor_audit (
    id BIGSERIAL PRIMARY KEY,
    username TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    operation TEXT NOT NULL,
    version_data JSONB NOT NULL
);

-- Indexes for common query patterns
CREATE INDEX idx_vendor_audit_username ON vendor_audit(username);
CREATE INDEX idx_vendor_audit_timestamp ON vendor_audit(timestamp DESC);
CREATE INDEX idx_vendor_audit_operation ON vendor_audit(operation);

-- Optional: GIN index on jsonb column for efficient JSON querying
CREATE INDEX idx_vendor_audit_version_data ON vendor_audit USING GIN(version_data);
```

### Code Organization
- Domain types: `io.sdkman.domain.AuditRecord`, `io.sdkman.domain.AuditOperation`
- Repository interface: `io.sdkman.domain.AuditRepository`
- Repository implementation: `io.sdkman.repos.AuditRepositoryImpl` (or add to existing file)
- Exposed table definition: Create `VendorAuditTable` object similar to existing `VersionsTable`
- Integration point: Update routing in `plugins/Routing.kt` to call audit repository

### Integration Pattern

```kotlin
// In Routing.kt - POST endpoint (pseudocode)
post("/versions") {
    val principal = call.principal<UserIdPrincipal>()
    val username = principal?.name ?: "unknown"

    // ... validation logic ...

    versionsRepository.save(version).fold(
        { error -> /* handle error */ },
        {
            // Version saved successfully, now audit it
            auditRepository.recordAudit(username, AuditOperation.POST, version)
                .tapLeft { auditError ->
                    // Log warning but don't fail the request
                    logger.warn("Audit logging failed for POST /versions: ${auditError.message}", auditError)
                }

            call.respond(HttpStatusCode.NoContent)
        }
    )
}
```

### Serialization Pattern

```kotlin
// Serialize Version to JSON string
fun Version.toJson(): String =
    Json.encodeToString(Version.serializer(), this)

// In audit repository implementation
suspend fun recordAudit(
    username: String,
    operation: AuditOperation,
    version: Version
): Either<DatabaseFailure, Unit> = either {
    transaction {
        VendorAuditTable.insert {
            it[this.username] = username
            it[this.timestamp] = Clock.System.now()
            it[this.operation] = operation.name
            it[this.versionData] = version.toJson()
        }
    }
}
```

## Specification by Example

### Example: POST creates audit record

**Request:**
```bash
POST /versions
Authorization: Basic dXNlcjpwYXNz
Content-Type: application/json

{
  "candidate": "java",
  "version": "17.0.1",
  "platform": "LINUX_X64",
  "url": "https://example.com/java-17.0.1.tar.gz",
  "distribution": "TEMURIN",
  "sha256sum": "abc123def456abc123def456abc123def456abc123def456abc123def456abc1"
}
```

**Response:** `204 No Content`

**Database State - versions table:**
New version record created with candidate=java, version=17.0.1, etc.

**Database State - version_data field:**
```json
{
    "candidate": "java",
    "version": "17.0.1",
    "platform": "LINUX_X64",
    "url": "https://example.com/java-17.0.1.tar.gz",
    "visible": true,
    "distribution": "TEMURIN",
    "sha256sum": "abc123def456abc123def456abc123def456abc123def456abc123def456abc1",
}
```

### Example: DELETE creates audit record

**Request:**
```bash
DELETE /versions
Authorization: Basic YWRtaW46cGFzcw==
Content-Type: application/json

{
  "candidate": "java",
  "version": "17.0.1",
  "distribution": "TEMURIN",
  "platform": "LINUX_X64"
}
```

**Response:** `204 No Content`

**Database State - versions table:**
Version record deleted (no longer exists)

**Database State - vendor_audit table:**
```json
{
    "candidate": "java",
    "version": "17.0.1",
    "platform": "LINUX_X64",
    "url": "https://example.com/java-17.0.1.tar.gz",
    "visible": true,
    "distribution": "TEMURIN"
}
```

Note: The audit record captures the complete version as it existed before deletion.

### Example: Audit failure doesn't block operation

**Scenario:** Database connection issue prevents audit record creation

**Request:**
```bash
POST /versions
Authorization: Basic dXNlcjpwYXNz
Content-Type: application/json

{
  "candidate": "kotlin",
  "version": "1.9.0",
  "platform": "UNIVERSAL",
  "url": "https://github.com/JetBrains/kotlin/releases/download/1.9.0/kotlin.zip"
}
```

**Response:** `204 No Content` (operation succeeds despite audit failure)

**Application Log:**
```
WARN [io.sdkman.routes.VersionRoutes] - Audit logging failed for POST /versions: Database connection timeout
```

**Database State - versions table:**
New version record created successfully

**Database State - vendor_audit table:**
No audit record created (but operation didn't fail)

### Example: Query audit logs via SQL

```sql
-- Find all audits by specific user
SELECT id, username, timestamp, operation, version_data->>'candidate' as candidate,
       version_data->>'version' as version
FROM vendor_audit
WHERE username = 'admin'
ORDER BY timestamp DESC;

-- Find all DELETE operations
SELECT * FROM vendor_audit
WHERE operation = 'DELETE'
ORDER BY timestamp DESC;

-- Find audits for specific candidate
SELECT * FROM vendor_audit
WHERE version_data->>'candidate' = 'java'
ORDER BY timestamp DESC;

-- Find audits within time range
SELECT * FROM vendor_audit
WHERE timestamp BETWEEN '2025-12-01' AND '2025-12-31'
ORDER BY timestamp DESC;
```

## Verification Checklist

### Architectural Compliance
- [ ] Audit domain types defined in `io.sdkman.domain` package
- [ ] AuditRepository interface defined in domain layer
- [ ] AuditRepository implementation in infrastructure layer (repos package)
- [ ] Follows existing patterns - repository interface in domain, implementation in repos, routing calls repositories directly
- [ ] Code follows RULE-001 through RULE-006 from rules/kotlin.md
- [ ] Uses Arrow Either for error handling consistently

### Database Schema
- [ ] Flyway migration file created (V7__create_vendor_audit_table.sql)
- [ ] vendor_audit table has id (BIGSERIAL PRIMARY KEY)
- [ ] vendor_audit table has username (TEXT NOT NULL)
- [ ] vendor_audit table has timestamp (TIMESTAMP WITH TIME ZONE NOT NULL)
- [ ] vendor_audit table has operation (TEXT NOT NULL)
- [ ] vendor_audit table has version_data (JSONB NOT NULL)
- [ ] Appropriate indexes created (username, timestamp, operation, jsonb)
- [ ] Migration runs successfully on clean database

### Functional Requirements
- [ ] POST /versions creates audit record with operation=POST
- [ ] DELETE /versions creates audit record with operation=DELETE
- [ ] Audit record captures username from authentication
- [ ] Audit record captures accurate timestamp
- [ ] Audit record contains complete Version data as JSON
- [ ] Version data JSON includes all fields (candidate, version, platform, url, optional fields)
- [ ] Optional fields (distribution, checksums) serialized correctly as null/value in JSON
- [ ] Audit failures are logged as warnings
- [ ] Audit failures DO NOT cause POST operation to fail
- [ ] Audit failures DO NOT cause DELETE operation to fail

### Testing
- [ ] All tests pass using Kotest framework
- [ ] Integration test: POST creates version and audit record
- [ ] Integration test: DELETE deletes version and creates audit record
- [ ] Integration test: Audit record has correct username
- [ ] Integration test: Audit record has correct timestamp
- [ ] Integration test: Audit record JSON deserializes back to Version
- [ ] Integration test: Audit failure doesn't block POST operation
- [ ] Integration test: Audit failure doesn't block DELETE operation
- [ ] Integration test: Audit failure logs warning
- [ ] Schema test: vendor_audit table exists with correct structure
- [ ] Edge case test: POST with all optional fields
- [ ] Edge case test: POST with minimal required fields
- [ ] Edge case test: DELETE with distribution=Some vs None

### Code Quality
- [ ] **No nullable types used** - follows Option pattern from kotlin.md rules
- [ ] Exposed table definition follows existing VersionsTable pattern
- [ ] Serialization uses kotlinx.serialization consistently
- [ ] Error handling uses Either pattern consistently
- [ ] Logging uses appropriate log level (WARN for audit failures)
- [ ] Code is well-organized in appropriate packages
- [ ] No code duplication between POST and DELETE audit logic